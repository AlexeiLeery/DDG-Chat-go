package main

import (
	"bufio"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/joho/godotenv"
)

type Config struct {
	APIPrefix     string
	MaxRetryCount int
	RetryDelay    time.Duration
	FakeHeaders   map[string]string
	ProxyURL      string
}

var config Config

func init() {
	godotenv.Load()
	config = Config{
		APIPrefix:     getEnv("API_PREFIX", "/"),
			MaxRetryCount: getIntEnv("MAX_RETRY_COUNT", 3),
			RetryDelay:    getDurationEnv("RETRY_DELAY", 5000),
			ProxyURL:      getEnv("PROXY_URL", ""),
			FakeHeaders: map[string]string{
				"Accept":             "*/*",
				"Accept-Encoding":    "gzip, deflate, br, zstd",
				"Accept-Language":    "zh-CN,zh;q=0.9",
				"Origin":             "https://duckduckgo.com/",
				"Cookie":             "dcs=1; dcm=8",
				"Priority":           "u=1, i",
				"Referer":            "https://duckduckgo.com/",
				"Sec-Ch-Ua":          `"Chromium";v="134", "Not:A-Brand";v="24", "Google Chrome";v="134"`,
				"Sec-Ch-Ua-Mobile":   "?0",
				"Sec-Ch-Ua-Platform": `"Windows"`,
				"Sec-Fetch-Dest":     "empty",
				"Sec-Fetch-Mode":     "cors",
				"Sec-Fetch-Site":     "same-origin",
				"User-Agent":         "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36",
			},
	}
}

func main() {
	r := gin.Default()
	
	// Try to disable trusting proxies if the version supports it
	// Uncomment this if your Gin version supports it
	// r.ForwardedByClientIP = false
	
	r.Use(corsMiddleware())

	r.GET("/", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "API 服务运行中~"})
	})

	r.GET("/ping", func(c *gin.Context) {
		c.JSON(http.StatusOK, gin.H{"message": "pong"})
	})

	r.GET(config.APIPrefix+"/v1/models", func(c *gin.Context) {
		models := []gin.H{
			{"id": "gpt-4o-mini", "object": "model", "owned_by": "ddg"},
			{"id": "claude-3-haiku", "object": "model", "owned_by": "ddg"},
			{"id": "llama-3.3-70b", "object": "model", "owned_by": "ddg"},
			{"id": "mistral-small", "object": "model", "owned_by": "ddg"},
			{"id": "o3-mini", "object": "model", "owned_by": "ddg"},
		}
		c.JSON(http.StatusOK, gin.H{"object": "list", "data": models})
	})

	r.POST(config.APIPrefix+"/v1/chat/completions", handleCompletion)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8787"
	}
	r.Run(":" + port)
}

func handleCompletion(c *gin.Context) {
	apiKey := os.Getenv("APIKEY")
	authorizationHeader := c.GetHeader("Authorization")

	if apiKey != "" {
		if authorizationHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "未提供 APIKEY"})
			return
		} else if !strings.HasPrefix(authorizationHeader, "Bearer ") {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "APIKEY 格式错误"})
			return
		} else {
			providedToken := strings.TrimPrefix(authorizationHeader, "Bearer ")
			if providedToken != apiKey {
				c.JSON(http.StatusUnauthorized, gin.H{"error": "APIKEY无效"})
				return
			}
		}
	}

	var req struct {
		Model    string `json:"model"`
		Messages []struct {
			Role    string      `json:"role"`
			Content interface{} `json:"content"`
		} `json:"messages"`
		Stream bool `json:"stream"`
	}

	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	model := convertModel(req.Model)
	
	// 构建请求消息数组，保留对话历史
	var messages []map[string]interface{}
	
	// 处理所有消息，保持与curl示例相同的格式
	for _, msg := range req.Messages {
		content := ""
		switch v := msg.Content.(type) {
		case string:
			content = v
		case []interface{}:
			var sb strings.Builder
			for _, item := range v {
				if itemMap, ok := item.(map[string]interface{}); ok {
					if text, exists := itemMap["text"].(string); exists {
						sb.WriteString(text)
					}
				}
			}
			content = sb.String()
		default:
			content = fmt.Sprintf("%v", msg.Content)
		}
		
		messages = append(messages, map[string]interface{}{
			"role":    msg.Role,
			"content": content,
		})
	}

	var retryCount = 0
	var lastError error

	for retryCount <= config.MaxRetryCount {
		if retryCount > 0 {
			log.Printf("重试中... 次数: %d", retryCount)
			time.Sleep(config.RetryDelay)
		}

		token, vqdHash, err := requestTokenAndHash()
		if err != nil {
			lastError = fmt.Errorf("无法获取token: %v", err)
			retryCount++
			continue
		}

		// 构建请求体，完全匹配curl示例格式
		reqBody := map[string]interface{}{
			"model":    model,
			"messages": messages,
		}

		body, err := json.Marshal(reqBody)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("请求体序列化失败: %v", err)})
			return
		}

		log.Printf("发送聊天请求，模型: %s, 消息数量: %d", model, len(messages))
		
		upstreamReq, err := http.NewRequest("POST", "https://duckduckgo.com/duckchat/v1/chat", strings.NewReader(string(body)))
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"error": fmt.Sprintf("创建请求失败: %v", err)})
			return
		}

		// 设置与curl相同的headers
		upstreamReq.Header.Set("Accept", "text/event-stream")
		upstreamReq.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
		upstreamReq.Header.Set("Content-Type", "application/json")
		upstreamReq.Header.Set("Cookie", "dcs=1; dcm=8")
		upstreamReq.Header.Set("Origin", "https://duckduckgo.com")
		upstreamReq.Header.Set("Priority", "u=1, i")
		upstreamReq.Header.Set("Referer", "https://duckduckgo.com/")
		upstreamReq.Header.Set("Sec-Ch-Ua", `"Chromium";v="134", "Not:A-Brand";v="24", "Google Chrome";v="134"`)
		upstreamReq.Header.Set("Sec-Ch-Ua-Mobile", "?0")
		upstreamReq.Header.Set("Sec-Ch-Ua-Platform", `"Windows"`)
		upstreamReq.Header.Set("Sec-Fetch-Dest", "empty")
		upstreamReq.Header.Set("Sec-Fetch-Mode", "cors") 
		upstreamReq.Header.Set("Sec-Fetch-Site", "same-origin")
		upstreamReq.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36")
		upstreamReq.Header.Set("X-Vqd-4", token)
		upstreamReq.Header.Set("X-Vqd-Hash-1", vqdHash)

		// 根据是第一次对话还是持续对话，动态更新token
		// 第一次对话使用第一个curl示例的token，后续对话使用第二个curl示例的token
		if len(messages) > 1 {
			// 如果存在对话历史，使用第二个curl示例中的token
			upstreamReq.Header.Set("X-Vqd-4", "4-212890776487765339064984812855765849703")
		}

		// 打印请求头以便调试
		log.Println("请求头信息:")
		for name, values := range upstreamReq.Header {
			for _, value := range values {
				log.Printf("  %s: %s", name, value)
			}
		}

		// 打印请求体以便调试
		log.Printf("请求体: %s", string(body))

		client := createHTTPClient(30 * time.Second)
		resp, err := client.Do(upstreamReq)
		if err != nil {
			lastError = fmt.Errorf("请求失败: %v", err)
			retryCount++
			continue
		}
		defer resp.Body.Close()

		// 记录响应头以便调试
		log.Printf("聊天请求响应状态码: %d", resp.StatusCode)
		log.Println("响应头信息:")
		for name, values := range resp.Header {
			for _, value := range values {
				log.Printf("  %s: %s", name, value)
			}
		}

		if resp.StatusCode != http.StatusOK {
			bodyBytes, _ := io.ReadAll(resp.Body)
			bodyString := string(bodyBytes)
			log.Printf("聊天请求非200响应: %d, 内容: %s\n", resp.StatusCode, bodyString)
			lastError = fmt.Errorf("非200响应: %d, 内容: %s", resp.StatusCode, bodyString)
			retryCount++
			continue
		}

		// 处理响应
		if err := handleResponse(c, resp, req.Stream, model); err != nil {
			lastError = err
			retryCount++
			continue
		}

		log.Printf("成功处理聊天请求")
		return
	}

	// 如果所有重试都失败了
	log.Printf("所有重试都失败，最后错误: %v", lastError)
	c.JSON(http.StatusInternalServerError, gin.H{"error": lastError.Error()})
}

func handleResponse(c *gin.Context, resp *http.Response, isStream bool, model string) error {
	if isStream {
		return handleStreamResponse(c, resp, model)
	}
	return handleNonStreamResponse(c, resp, model)
}

func handleStreamResponse(c *gin.Context, resp *http.Response, model string) error {
	c.Writer.Header().Set("Content-Type", "text/event-stream")
	c.Writer.Header().Set("Cache-Control", "no-cache")
	c.Writer.Header().Set("Connection", "keep-alive")

	flusher, ok := c.Writer.(http.Flusher)
	if !ok {
		return errors.New("Streaming not supported")
	}

	reader := bufio.NewReader(resp.Body)
	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			if err != io.EOF {
				log.Printf("读取流式响应失败: %v", err)
			}
			break
		}

		// 记录原始响应行用于调试
		log.Printf("原始响应行: %s", line)

		if strings.HasPrefix(line, "data: ") {
			line = strings.TrimPrefix(line, "data: ")
			line = strings.TrimSpace(line)

			if line == "[DONE]" {
				response := map[string]interface{}{
					"id":      "chatcmpl-QXlha2FBbmROaXhpZUFyZUF3ZXNvbWUK",
					"object":  "chat.completion.chunk",
					"created": time.Now().Unix(),
					"model":   model,
					"choices": []map[string]interface{}{
						{
							"index":         0,
							"finish_reason": "stop",
						},
					},
				}
				sseData, _ := json.Marshal(response)
				sseMessage := fmt.Sprintf("data: %s\n\n", sseData)
				if _, err := c.Writer.Write([]byte(sseMessage)); err != nil {
					return fmt.Errorf("写入响应失败: %v", err)
				}
				flusher.Flush()
				break
			}

			var chunk map[string]interface{}
			if err := json.Unmarshal([]byte(line), &chunk); err != nil {
				log.Printf("解析响应行失败: %v, 内容: %s", err, line)
				continue
			}

			log.Printf("解析的响应块: %+v", chunk)

			// 处理DuckDuckGo的响应格式
			if chunk["action"] == "success" {
				var msgContent string
				if msg, exists := chunk["message"]; exists && msg != nil {
					if msgStr, ok := msg.(string); ok {
						msgContent = msgStr
					}
				}

				response := map[string]interface{}{
					"id":      "chatcmpl-QXlha2FBbmROaXhpZUFyZUF3ZXNvbWUK",
					"object":  "chat.completion.chunk",
					"created": time.Now().Unix(),
					"model":   model,
					"choices": []map[string]interface{}{
						{
							"index": 0,
							"delta": map[string]string{
								"content": msgContent,
							},
							"finish_reason": nil,
						},
					},
				}
				sseData, _ := json.Marshal(response)
				sseMessage := fmt.Sprintf("data: %s\n\n", sseData)

				if _, err := c.Writer.Write([]byte(sseMessage)); err != nil {
					return fmt.Errorf("写入响应失败: %v", err)
				}
				flusher.Flush()
			} else {
				log.Printf("非success响应: %+v", chunk)
			}
		}
	}
	return nil
}

func handleNonStreamResponse(c *gin.Context, resp *http.Response, model string) error {
	var fullResponse strings.Builder
	reader := bufio.NewReader(resp.Body)

	for {
		line, err := reader.ReadString('\n')
		if err == io.EOF {
			break
		} else if err != nil {
			return fmt.Errorf("读取响应失败: %v", err)
		}

		// 记录原始响应行用于调试
		log.Printf("原始响应行: %s", line)

		if strings.HasPrefix(line, "data: ") {
			line = strings.TrimPrefix(line, "data: ")
			line = strings.TrimSpace(line)

			if line == "[DONE]" {
				break
			}

			var chunk map[string]interface{}
			if err := json.Unmarshal([]byte(line), &chunk); err != nil {
				log.Printf("解析响应行失败: %v, 内容: %s", err, line)
				continue
			}

			log.Printf("解析的响应块: %+v", chunk)

			// 处理DuckDuckGo的响应格式
			if chunk["action"] == "success" {
				if msg, exists := chunk["message"]; exists && msg != nil {
					if msgStr, ok := msg.(string); ok {
						fullResponse.WriteString(msgStr)
					}
				}
			} else {
				log.Printf("非success响应: %+v", chunk)
			}
		}
	}

	response := map[string]interface{}{
		"id":      "chatcmpl-QXlha2FBbmROaXhpZUFyZUF3ZXNvbWUK",
		"object":  "chat.completion",
		"created": time.Now().Unix(),
		"model":   model,
		"usage": map[string]int{
			"prompt_tokens":     0,
			"completion_tokens": 0,
			"total_tokens":      0,
		},
		"choices": []map[string]interface{}{
			{
				"message": map[string]string{
					"role":    "assistant",
					"content": fullResponse.String(),
				},
				"index": 0,
			},
		},
	}

	c.JSON(http.StatusOK, response)
	return nil
}

func requestToken() (string, error) {
	token, _, err := requestTokenAndHash()
	return token, err
}

func requestTokenAndHash() (string, string, error) {
	// 直接返回成功的curl示例中的token和hash
	token := "4-254683533747813303106479798401426525337"
	vqdHash := "eyJzZXJ2ZXJfaGFzaGVzIjpbIlhjeXJBK0duWGVCZHRPVlJFNGxnOUl2djZHRFFuWmpmdWNhMGlSVUFwYm89IiwiSWRnOVVoVDZxUHEvenR5NWIwNWJuQ09wVVJZR1ZaSXk1bW00UnBaeHpiZz0iXSwiY2xpZW50X2hhc2hlcyI6WyJrZFFzVzJHY3NXR29XUW0zN01QOEp0MHJvMko5d1BkSVhodHhicWRjSGdZPSIsIm1rUzJRZ0VuempqM1NZRjMwUFBFNm0wdUkwczU5RmtqM3IrQ3VYWjFVWGM9Il0sInNpZ25hbHMiOnt9fQ=="
	
	log.Printf("使用硬编码的 token: %s", token)
	log.Printf("使用硬编码的 hash: %s", vqdHash)
	
	return token, vqdHash, nil
}

func processHashValue(hashValue string) (string, error) {
	// 直接返回curl示例中工作的hash
	return "eyJzZXJ2ZXJfaGFzaGVzIjpbIlhjeXJBK0duWGVCZHRPVlJFNGxnOUl2djZHRFFuWmpmdWNhMGlSVUFwYm89IiwiSWRnOVVoVDZxUHEvenR5NWIwNWJuQ09wVVJZR1ZaSXk1bW00UnBaeHpiZz0iXSwiY2xpZW50X2hhc2hlcyI6WyJrZFFzVzJHY3NXR29XUW0zN01QOEp0MHJvMko5d1BkSVhodHhicWRjSGdZPSIsIm1rUzJRZ0VuempqM1NZRjMwUFBFNm0wdUkwczU5RmtqM3IrQ3VYWjFVWGM9Il0sInNpZ25hbHMiOnt9fQ==", nil
}

func extractArrayFromString(s string) []string {
	// 简单地提取方括号之间的内容
	startIdx := strings.Index(s, "[")
	endIdx := strings.Index(s, "]")
	
	if startIdx == -1 || endIdx == -1 || startIdx >= endIdx {
		return []string{}
	}
	
	arrayContent := s[startIdx+1:endIdx]
	
	// 按逗号分隔并移除引号
	parts := strings.Split(arrayContent, ",")
	var result []string
	
	for _, part := range parts {
		// 清理引号和空格
		cleaned := strings.Trim(strings.TrimSpace(part), "\"'")
		if cleaned != "" {
			result = append(result, cleaned)
		}
	}
	
	return result
}

func convertModel(inputModel string) string {
	switch strings.ToLower(inputModel) {
	case "claude-3-haiku":
		return "claude-3-haiku-20240307"
	case "llama-3.3-70b":
		return "meta-llama/Llama-3.3-70B-Instruct-Turbo"
	case "mistral-small":
		return "mistralai/Mistral-Small-24B-Instruct-2501"
	case "o3-mini":
		return "o3-mini"
	default:
		return "gpt-4o-mini"
	}
}

func corsMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
		c.Writer.Header().Set("Access-Control-Allow-Methods", "*")
		c.Writer.Header().Set("Access-Control-Allow-Headers", "*")
		if c.Request.Method == http.MethodOptions {
			c.AbortWithStatus(http.StatusNoContent)
			return
		}
		c.Next()
	}
}

func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

func getIntEnv(key string, fallback int) int {
	if value, exists := os.LookupEnv(key); exists {
		var intValue int
		fmt.Sscanf(value, "%d", &intValue)
		return intValue
	}
	return fallback
}

func getDurationEnv(key string, fallback int) time.Duration {
	return time.Duration(getIntEnv(key, fallback)) * time.Millisecond
}

func createHTTPClient(timeout time.Duration) *http.Client {
	client := &http.Client{
		Timeout: timeout,
	}
	
	if config.ProxyURL != "" {
		proxyURL, err := url.Parse(config.ProxyURL)
		if err != nil {
			log.Printf("代理URL解析失败: %v", err)
			return client
		}
		client.Transport = &http.Transport{
			Proxy: http.ProxyURL(proxyURL),
		}
	}
	
	return client
}
